---
title: LowLevelMouseProc callback function (Windows)
TOCTitle: LowLevelMouseProc callback function
ms:assetid: VS|winui|~\winui\windowsuserinterface\windowing\hooks\hookreference\hookfunctions\lowlevelmouseproc.htm
ms:mtpsurl: https://msdn.microsoft.com/en-us/library/ms644986(v=VS.85)
ms:contentKeyID: 5641720
ms.date: 03/30/2018
mtps_version: v=VS.85
f1_keywords:
- LowLevelMouseProc
- HC_ACTION
- winuser/LowLevelMouseProc
dev_langs:
- C++
- C
api_location:
- Winuser.h
api_name:
- LowLevelMouseProc
api_type:
- UserDefined
product:
- Windows
topic_type:
- apiref
- kbSyntax
product_family_name: VS
ROBOTS: INDEX,FOLLOW
---

# LowLevelMouseProc callback function

An application-defined or library-defined callback function used with the [**SetWindowsHookEx**](https://msdn.microsoft.com/en-us/library/ms644990\(v=vs.85\)) function. The system calls this function every time a new mouse input event is about to be posted into a thread input queue.

The **HOOKPROC** type defines a pointer to this callback function. *LowLevelMouseProc* is a placeholder for the application-defined or library-defined function name.

## Syntax

``` c++
LRESULT CALLBACK LowLevelMouseProc(
  _In_ int    nCode,
  _In_ WPARAM wParam,
  _In_ LPARAM lParam
);
```

## Parameters

  - *nCode* \[in\]  
    Type: **int**
    
    A code the hook procedure uses to determine how to process the message. If *nCode* is less than zero, the hook procedure must pass the message to the [**CallNextHookEx**](https://msdn.microsoft.com/en-us/library/ms644974\(v=vs.85\)) function without further processing and should return the value returned by **CallNextHookEx**. This parameter can be one of the following values.
    
    <table>
    <colgroup>
    <col style="width: 50%" />
    <col style="width: 50%" />
    </colgroup>
    <thead>
    <tr class="header">
    <th>Value</th>
    <th>Meaning</th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td><span id="HC_ACTION"></span><span id="hc_action"></span>
    <strong>HC_ACTION</strong>
    0</td>
    <td><p>The <em>wParam</em> and <em>lParam</em> parameters contain information about a mouse message.</p></td>
    </tr>
    </tbody>
    </table>
    
     

  - *wParam* \[in\]  
    Type: **WPARAM**
    
    The identifier of the mouse message. This parameter can be one of the following messages: [**WM\_LBUTTONDOWN**](https://msdn.microsoft.com/en-us/library/ms645607\(v=vs.85\)), [**WM\_LBUTTONUP**](https://msdn.microsoft.com/en-us/library/ms645608\(v=vs.85\)), [**WM\_MOUSEMOVE**](https://msdn.microsoft.com/en-us/library/ms645616\(v=vs.85\)), [**WM\_MOUSEWHEEL**](https://msdn.microsoft.com/en-us/library/ms645617\(v=vs.85\)), [**WM\_MOUSEHWHEEL**](https://msdn.microsoft.com/en-us/library/ms645614\(v=vs.85\)), [**WM\_RBUTTONDOWN**](https://msdn.microsoft.com/en-us/library/ms646242\(v=vs.85\)), or [**WM\_RBUTTONUP**](https://msdn.microsoft.com/en-us/library/ms646243\(v=vs.85\)).

  - *lParam* \[in\]  
    Type: **LPARAM**
    
    A pointer to an [**MSLLHOOKSTRUCT**](https://msdn.microsoft.com/en-us/library/ms644970\(v=vs.85\)) structure.

## Return value

Type: ****

Type: LRESULT

If *nCode* is less than zero, the hook procedure must return the value returned by [**CallNextHookEx**](https://msdn.microsoft.com/en-us/library/ms644974\(v=vs.85\)).

If *nCode* is greater than or equal to zero, and the hook procedure did not process the message, it is highly recommended that you call [**CallNextHookEx**](https://msdn.microsoft.com/en-us/library/ms644974\(v=vs.85\)) and return the value it returns; otherwise, other applications that have installed [**WH\_MOUSE\_LL**](https://msdn.microsoft.com/en-us/library/ms644959\(v=vs.85\)) hooks will not receive hook notifications and may behave incorrectly as a result. If the hook procedure processed the message, it may return a nonzero value to prevent the system from passing the message to the rest of the hook chain or the target window procedure.

## Remarks

An application installs the hook procedure by specifying the [**WH\_MOUSE\_LL**](https://msdn.microsoft.com/en-us/library/ms644959\(v=vs.85\)) hook type and a pointer to the hook procedure in a call to the [**SetWindowsHookEx**](https://msdn.microsoft.com/en-us/library/ms644990\(v=vs.85\)) function.

This hook is called in the context of the thread that installed it. The call is made by sending a message to the thread that installed the hook. Therefore, the thread that installed the hook must have a message loop.

The mouse input can come from the local mouse driver or from calls to the [**mouse\_event**](https://msdn.microsoft.com/en-us/library/ms646260\(v=vs.85\)) function. If the input comes from a call to **mouse\_event**, the input was "injected". However, the [**WH\_MOUSE\_LL**](https://msdn.microsoft.com/en-us/library/ms644959\(v=vs.85\)) hook is not injected into another process. Instead, the context switches back to the process that installed the hook and it is called in its original context. Then the context switches back to the application that generated the event.

The hook procedure should process a message in less time than the data entry specified in the **LowLevelHooksTimeout** value in the following registry key:

**HKEY\_CURRENT\_USER**\\**Control Panel**\\**Desktop**

The value is in milliseconds. If the hook procedure times out, the system passes the message to the next hook. However, on Windows 7 and later, the hook is silently removed without being called. There is no way for the application to know whether the hook is removed. 

**Windows 10 version 1709 and later** The maximum timeout value the system allows is 1000 milliseconds (1 second). The system will default to using a 1000 millisecond timeout if the **LowLevelHooksTimeout** value is set to a value larger than 1000. 

**Note**  Debug hooks cannot track this type of low level mouse hooks. If the application must use low level hooks, it should run the hooks on a dedicated thread that passes the work off to a worker thread and then immediately returns. In most cases where the application needs to use low level hooks, it should monitor raw input instead. This is because raw input can asynchronously monitor mouse and keyboard messages that are targeted for other threads more effectively than low level hooks can. For more information on raw input, see [Raw Input](https://msdn.microsoft.com/en-us/library/ms645536\(vs.85\).aspx).

 

## Requirements

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>Minimum supported client</p></td>
<td><p>Windows 2000 Professional [desktop apps only]</p></td>
</tr>
<tr class="even">
<td><p>Minimum supported server</p></td>
<td><p>Windows 2000 Server [desktop apps only]</p></td>
</tr>
<tr class="odd">
<td><p>Header</p></td>
<td>Winuser.h (include Windows.h)</td>
</tr>
</tbody>
</table>


## See also

**Reference**

[**CallNextHookEx**](https://msdn.microsoft.com/en-us/library/ms644974\(v=vs.85\))

[**mouse\_event**](https://msdn.microsoft.com/en-us/library/ms646260\(v=vs.85\))

[**MSLLHOOKSTRUCT**](https://msdn.microsoft.com/en-us/library/ms644970\(v=vs.85\))

[**SetWindowsHookEx**](https://msdn.microsoft.com/en-us/library/ms644990\(v=vs.85\))

[**WM\_LBUTTONDOWN**](https://msdn.microsoft.com/en-us/library/ms645607\(v=vs.85\))

[**WM\_LBUTTONUP**](https://msdn.microsoft.com/en-us/library/ms645608\(v=vs.85\))

[**WM\_MOUSEMOVE**](https://msdn.microsoft.com/en-us/library/ms645616\(v=vs.85\))

[**WM\_MOUSEWHEEL**](https://msdn.microsoft.com/en-us/library/ms645617\(v=vs.85\))

[**WM\_RBUTTONDOWN**](https://msdn.microsoft.com/en-us/library/ms646242\(v=vs.85\))

[**WM\_RBUTTONUP**](https://msdn.microsoft.com/en-us/library/ms646243\(v=vs.85\))

**Conceptual**

[Hooks](https://msdn.microsoft.com/en-us/library/ms632589\(v=vs.85\))

[About Hooks](https://msdn.microsoft.com/en-us/library/ms644959\(v=vs.85\))

