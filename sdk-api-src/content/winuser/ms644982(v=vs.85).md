---
title: JournalPlaybackProc callback function (Windows)
TOCTitle: JournalPlaybackProc callback function
ms:assetid: VS|winui|~\winui\windowsuserinterface\windowing\hooks\hookreference\hookfunctions\journalplaybackproc.htm
ms:mtpsurl: https://msdn.microsoft.com/en-us/library/ms644982(v=VS.85)
ms:contentKeyID: 5641712
ms.date: 03/30/2018
mtps_version: v=VS.85
f1_keywords:
- JournalPlaybackProc
- HC_GETNEXT
- HC_SKIP
- HC_SYSMODALON
- HC_NOREMOVE
- HC_SYSMODALOFF
- winuser/JournalPlaybackProc
dev_langs:
- C++
- C
api_location:
- Winuser.h
api_name:
- JournalPlaybackProc
api_type:
- UserDefined
product:
- Windows
topic_type:
- apiref
- kbSyntax
product_family_name: VS
ROBOTS: INDEX,FOLLOW
---

# JournalPlaybackProc callback function

> [!WARNING]  
> Journaling Hooks APIs are unsupported starting in Windows 11 and will be removed in a future release. Because of this, we highly recommend calling the [**SendInput**](https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-sendinput) TextInput API instead.

An application-defined or library-defined callback function used with the [**SetWindowsHookEx**](https://msdn.microsoft.com/en-us/library/ms644990\(v=vs.85\)) function. Typically, an application uses this function to play back a series of mouse and keyboard messages recorded previously by the [*JournalRecordProc*](ms644983\(v=vs.85\).md) hook procedure. As long as a *JournalPlaybackProc* hook procedure is installed, regular mouse and keyboard input is disabled.

The **HOOKPROC** type defines a pointer to this callback function. *JournalPlaybackProc* is a placeholder for the application-defined or library-defined function name.

## Syntax

``` c++
LRESULT CALLBACK JournalPlaybackProc(
  _In_ int    code,
       WPARAM wParam,
  _In_ LPARAM lParam
);
```

## Parameters

  - *code* \[in\]  
    Type: **int**
    
    A code the hook procedure uses to determine how to process the message. If *code* is less than zero, the hook procedure must pass the message to the [**CallNextHookEx**](https://msdn.microsoft.com/en-us/library/ms644974\(v=vs.85\)) function without further processing and should return the value returned by **CallNextHookEx**. This parameter can be one of the following values.
    
    <table>
    <colgroup>
    <col style="width: 50%" />
    <col style="width: 50%" />
    </colgroup>
    <thead>
    <tr class="header">
    <th>Value</th>
    <th>Meaning</th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td><span id="HC_GETNEXT"></span><span id="hc_getnext"></span>
    <strong>HC_GETNEXT</strong>
    1</td>
    <td><p>The hook procedure must copy the current mouse or keyboard message to the <a href="/windows/win32/api/winuser/ns-winuser-eventmsg"><strong>EVENTMSG</strong></a> structure pointed to by the <em>lParam</em> parameter.</p></td>
    </tr>
    <tr class="even">
    <td><span id="HC_NOREMOVE"></span><span id="hc_noremove"></span>
    <strong>HC_NOREMOVE</strong>
    3</td>
    <td><p>An application has called the <a href="/windows/win32/api/winuser/nf-winuser-peekmessagea"><strong>PeekMessage</strong></a> function with <em>wRemoveMsg</em> set to <strong>PM_NOREMOVE</strong>, indicating that the message is not removed from the message queue after <strong>PeekMessage</strong> processing.</p></td>
    </tr>
    <tr class="odd">
    <td><span id="HC_SKIP"></span><span id="hc_skip"></span>
    <strong>HC_SKIP</strong>
    2</td>
    <td><p>The hook procedure must prepare to copy the next mouse or keyboard message to the <a href="/windows/win32/api/winuser/ns-winuser-eventmsg"><strong>EVENTMSG</strong></a> structure pointed to by <em>lParam</em>. Upon receiving the <strong>HC_GETNEXT</strong> code, the hook procedure must copy the message to the structure.</p></td>
    </tr>
    <tr class="even">
    <td><span id="HC_SYSMODALOFF"></span><span id="hc_sysmodaloff"></span>
    <strong>HC_SYSMODALOFF</strong>
    5</td>
    <td><p>A system-modal dialog box has been destroyed. The hook procedure must resume playing back the messages.</p></td>
    </tr>
    <tr class="odd">
    <td><span id="HC_SYSMODALON"></span><span id="hc_sysmodalon"></span>
    <strong>HC_SYSMODALON</strong>
    4</td>
    <td><p>A system-modal dialog box is being displayed. Until the dialog box is destroyed, the hook procedure must stop playing back messages.</p></td>
    </tr>
    </tbody>
    </table>
    
     

  - *wParam*  
    Type: **WPARAM**
    
    This parameter is not used.

  - *lParam* \[in\]  
    Type: **LPARAM**
    
    A pointer to an [**EVENTMSG**](https://msdn.microsoft.com/en-us/library/ms644966\(v=vs.85\)) structure that represents a message being processed by the hook procedure. This parameter is valid only when the *code* parameter is **HC\_GETNEXT**.

## Return value

Type: ****

Type: LRESULT

To have the system wait before processing the message, the return value must be the amount of time, in clock ticks, that the system should wait. (This value can be computed by calculating the difference between the **time** members in the current and previous input messages.) To process the message immediately, the return value should be zero. The return value is used only if the hook code is **HC\_GETNEXT**; otherwise, it is ignored.

## Remarks

A *JournalPlaybackProc* hook procedure should copy an input message to the *lParam* parameter. The message must have been previously recorded by using a [*JournalRecordProc*](ms644983\(v=vs.85\).md) hook procedure, which should not modify the message.

To retrieve the same message over and over, the hook procedure can be called several times with the *code* parameter set to **HC\_GETNEXT** without an intervening call with *code* set to **HC\_SKIP**.

If *code* is **HC\_GETNEXT** and the return value is greater than zero, the system sleeps for the number of milliseconds specified by the return value. When the system continues, it calls the hook procedure again with *code* set to **HC\_GETNEXT** to retrieve the same message. The return value from this new call to *JournalPlaybackProc* should be zero; otherwise, the system will go back to sleep for the number of milliseconds specified by the return value, call *JournalPlaybackProc* again, and so on. The system will appear to be not responding.

Unlike most other global hook procedures, the [*JournalRecordProc*](ms644983\(v=vs.85\).md) and *JournalPlaybackProc* hook procedures are always called in the context of the thread that set the hook.

After the hook procedure returns control to the system, the message continues to be processed. If *code* is **HC\_SKIP**, the hook procedure must prepare to return the next recorded event message on its next call.

Install the *JournalPlaybackProc* hook procedure by specifying the [**WH\_JOURNALPLAYBACK**](https://msdn.microsoft.com/en-us/library/ms644959\(v=vs.85\)) type and a pointer to the hook procedure in a call to the [**SetWindowsHookEx**](https://msdn.microsoft.com/en-us/library/ms644990\(v=vs.85\)) function.

If the user presses CTRL+ESC OR CTRL+ALT+DEL during journal playback, the system stops the playback, unhooks the journal playback procedure, and posts a [**WM\_CANCELJOURNAL**](https://msdn.microsoft.com/en-us/library/ms644971\(v=vs.85\)) message to the journaling application.

If the hook procedure returns a message in the range **WM\_KEYFIRST** to **WM\_KEYLAST**, the following conditions apply:

  - The **paramL** member of the [**EVENTMSG**](https://msdn.microsoft.com/en-us/library/ms644966\(v=vs.85\)) structure specifies the virtual key code of the key that was pressed.
  - The **paramH** member of the [**EVENTMSG**](https://msdn.microsoft.com/en-us/library/ms644966\(v=vs.85\)) structure specifies the scan code.
  - There's no way to specify a repeat count. The event is always taken to represent one key event.

## Requirements

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>Minimum supported client</p></td>
<td><p>Windows 2000 Professional [desktop apps only]</p></td>
</tr>
<tr class="even">
<td><p>Minimum supported server</p></td>
<td><p>Windows 2000 Server [desktop apps only]</p></td>
</tr>
<tr class="odd">
<td><p>Header</p></td>
<td>Winuser.h (include Windows.h)</td>
</tr>
</tbody>
</table>


## See also

**Reference**

[**CallNextHookEx**](https://msdn.microsoft.com/en-us/library/ms644974\(v=vs.85\))

[**EVENTMSG**](https://msdn.microsoft.com/en-us/library/ms644966\(v=vs.85\))

[*JournalRecordProc*](ms644983\(v=vs.85\).md)

[**PeekMessage**](https://msdn.microsoft.com/en-us/library/ms644943\(v=vs.85\))

[**SetWindowsHookEx**](https://msdn.microsoft.com/en-us/library/ms644990\(v=vs.85\))

[**WM\_CANCELJOURNAL**](https://msdn.microsoft.com/en-us/library/ms644971\(v=vs.85\))

**Conceptual**

[Hooks](https://msdn.microsoft.com/en-us/library/ms632589\(v=vs.85\))